!
!  14_TwoLevelSolver.f
!
!  Fixed-Format Fortran Source File
!  Generated by PGI Visual Fortran(R)
!  2/2/2011 8:06:39 PM
!	
	subroutine MakeIgJgForSolver()
	use ForSolver
	use parametrs	
	implicit real*8 (a-h, o-z)

	integer, allocatable :: list(:,:)
	integer, allocatable :: listbeg(:)

	         allocate(listbeg(M), stat=ierr1)
			 allocate(list(2,10000000), stat=ierr2)
			 allocate(igS(M+1), stat=ierr3)

	if(ierr1/=0)stop 'Allocation error in listbeg'	
	if(ierr2/=0)stop 'Allocation error in list'
	if(ierr3/=0)stop 'Allocation error in ig'

	listsize=0
	listbeg=0
	
	do ielem=1, ntetr
		do i=1, 10
	       k=IndexOfUnknownsS(ielem,i)
	       do j=i+1,10
	          ind1=k
	          ind2=IndexOfUnknownsS(ielem,j)
	          if(ind2.lt.ind1) then
	             ind1=ind2
	             ind2=k
	          end if
	          iaddr=listbeg(ind2)
	          if(iaddr.eq.0) then
	            listsize=listsize+1
	            listbeg(ind2)=listsize
	            list(1,listsize)=ind1
	            list(2,listsize)=0
	         else
                  do while(list(1,iaddr).lt.ind1.and.list(2,iaddr).gt.0)
	                iaddr=list(2,iaddr)
	            end do
	            if (list(1,iaddr).gt.ind1)then
	                listsize=listsize+1
	                list(1,listsize)=list(1,iaddr)
		            list(2,listsize)=list(2,iaddr)
	                list(1,iaddr)=ind1
	                list(2,iaddr)=listsize
	            else
	                if(list(1,iaddr).lt.ind1)then
	                   listsize=listsize+1
	                   list(2,iaddr)=listsize	 
	                   list(1,listsize)=ind1
		               list(2,listsize)=0
			   endif
			  endif
			endif					                     
		   end do
		end do
	end do
	
	igS(1)=1
	do i=1,M
		igS(i+1)=igS(i)
	    iaddr=listbeg(i)
	    do while(iaddr.ne.0)
	       igS(i+1)=igS(i+1)+1
	       iaddr=list(2,iaddr)
	    end do
	end do

	krS=igS(M+1)-1
	print *, 'krS=',krS
		
		allocate(jgS(krS), stat=ierr4)
	    if(ierr4/=0)stop 'Allocation error in jg'

	do i=1,M
		k=igS(i)
	    iaddr=listbeg(i)
	    do while(iaddr.ne.0)
	       jgS(k)=list(1,iaddr)
	       k=k+1
	       iaddr=list(2,iaddr)
	    end do
	end do

	deallocate(listbeg)
	deallocate(list)

	allocate(diS(M), stat=ierr1)
	if(ierr1/=0)stop 'Allocation error in diS'	

	allocate(gguS(krS), stat=ierr2)
	if(ierr2/=0)stop 'Allocation error in gguS'

	allocate(gglS(krS), stat=ierr3)
	if(ierr3/=0)stop 'Allocation error in gglS'
	end


	function IndexOfUnknownsS(ielem,i)
	use ForSolver
	use OblastByEdge
	use parametrs	
	implicit real*8 (a-h, o-z)

	  selectcase (i)
		case(1:4)
			i_edge=nodes_tetr(i,ielem)
			IndexOfUnknownsS=i_edge				
			return
		case(5:10)
			number=i-4
			i_edge=n_edges_tetr(number,ielem)
			IndexOfUnknownsS=nodes+i_edge
			return	
		endselect 	
	end
	
	
	subroutine TwoLevelSolver(ig,jg,ggl,ggu,di,right,x,epsS)
	use ForSolver
	use parametrs	
      use OblastByEdge
	implicit real*8 (a-h, o-z)
	real*8  b_norma, norma
	dimension ig(*),jg(*)
	complex*16 :: ggu(*), ggl(*), di(*), right(*), x(*)
	
	complex*16, allocatable :: g(:)
	complex*16, allocatable :: y(:)
	complex*16, allocatable :: q(:)
	complex*16, allocatable :: z(:)
	complex*16, allocatable :: r(:)	
	
	allocate(r(N),stat=ierr)
	if(ierr.ne.0) stop 'Allocation error in Two r'

	allocate(q(N),stat=ierr)
	if(ierr.ne.0) stop 'Allocation error in Two q'

	allocate(g(M),stat=ierr)
	if(ierr.ne.0) stop 'Allocation error in Two g'

	allocate(y(M),stat=ierr)
	if(ierr.ne.0) stop 'Allocation error in Two y'

	allocate(z(N),stat=ierr)
	if(ierr.ne.0) stop 'Allocation error in Two z'

	! нулева€ итераци€
	g=(0.d0,0.d0)
	y=(0.d0,0.d0)
	q=(0.d0,0.d0)
	z=(0.d0,0.d0)
	r=(0.d0,0.d0)	

!	call umnog(di,ggu,ggl,ig,jg,x0,q,N,kr) ! A*x0=q
	do i=1, N
	   r(i)=right(i) !-q(i)
	end do

	f_norma=scalar3(right,right,N) !Scalar(right,right,N)
	f_norma=sqrt(f_norma)
	epsGMRSS=1.D-1
	epsGMRS=9.D-1
	alfa=0.7D0
	a_norma=scalar3(r,r,N) !Scalar(r,r,N)
	a_norma=sqrt(a_norma)	
	! основной цикл	
	do ix=1,maxiter
		iTransp=1
		call MultPr(r,g,iTransp)  ! g=P^T*r_j-1
		do i=1, M
			iy=FindCheckBonds(i) !с узлами
			if(iy.eq.1)then ! нашли узел или ребро среди краевых
				g(i)=(0.D0,0.D0)
			endif
		enddo
		call CoCG(igS,jgS,gglS,gguS,diS,g,y,M,krs,epsGMRSS)
!		do i=1, M
!			iy=FindCheckBonds(i) !с узлами
!			if(iy.eq.1)then ! нашли узел или ребро среди краевых
!				y(i)=(0.D0,0.D0)
!			endif
!		enddo		
		iTransp=0
		call MultPr(y,q,iTransp)  ! q=P*y
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		do jj = 1, num_0
                    iz = nbondary_zero(jj) 
                    q(iz) = (0.D0, 0.D0)
                    q(iz + nedges) = (0.D0, 0.D0) 
                enddo

		do jj = 1, num_E0
                    iz = nbondary_one(jj) 
                    q(iz) = (0.D0, 0.D0)
                    q(iz + nedges) = (0.D0, 0.D0) 
                enddo
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		do i=1, N
			x(i)=x(i)+q(i)
		enddo
		call umnogComplex(di,ggu,ggl,ig,jg,x,q,N,kr) ! A*x=q
		do i=1, N 
			r(i)=right(i)-q(i)
		enddo
		call CoCG(ig,jg,ggl,ggu,di,r,z,N,kr,epsGMRS)
		b_norma=scalar3(r,r,N)!Scalar(r,r,N)
		b_norma=sqrt(b_norma)
		epsGMRS=alfa*(a_norma/b_norma)
!	print * , "RESIDIAL_2->",epsGMRS, a_norma,b_norma	
		do i=1, N !N/2	
!			iy=checkX(i)
!			if(iy.eq.1)then
!				x(i)=0.D0
!				x(i+nedges)=0.D0
!			else
				x(i)=x(i)+z(i)
!				x(i+nedges)=x(i+nedges)+z(i+nedges)
!			endif	
		enddo
		
		call umnogComplex(di,ggu,ggl,ig,jg,x,q,N,kr) ! A*x=q
		do i=1, N
			r(i)=right(i)-q(i)
		enddo	
	    a_norma=scalar3(r,r,N)!Scalar(r,r,N)
	    a_norma=sqrt(a_norma)
	    norma=a_norma/f_norma
		
	    if (norma.lt.epsS) then
			print * , "TWOLEVEL->", ix, norma	    
	       goto 10
	    end if
	print * , "TWOLEVEL->", ix, norma
	end do

10    print * , ix, a_norma

	deallocate(g)	
	deallocate(y)
	deallocate(q)
	deallocate(z)
	deallocate(r)
	end
	
	

	subroutine MultPr(X,Rez,iTransp)
	use OblastByEdge
	
	use parametrs	
	implicit real*8 (a-h, o-z)
	complex*16 :: Rez(*), X(*)
	
	if(iTransp.eq.0)then ! то умножение просто на P Rez[N]
		do i=1, N
			Rez(i)=0.D0
		enddo
		do i=1, nedges
			N1=n_edges(1,i)  ! из этого узла выходит, т.е. -1
			N2=n_edges(2,i)  ! в этот   узел входит, т.е. 1
			Rez(i)=-X(N1)+X(N2)	
		end do	
		
		ix=nodes+1       ! по нижней части матрица св€зей
		do i=nedges+1,M-nodes+nedges !N  ќѕј—Ќќ≈ ћ≈—“ќ!!!!!!!!!!!!!!!!!!!!!!!!
			Rez(i)=X(ix)
			ix=ix+1		   			
		enddo
	else		! то умножение просто на P^T Rez[M]
		do i=1, nodes
			Rez(i)=0.D0
		enddo	
		
		do i=1, nedges
			N1=n_edges(1,i)  ! из этого узла выходит, т.е. -1
			Rez(N1)=Rez(N1)-X(i)
			N2=n_edges(2,i)  ! в этот   узел входит, т.е. 1	
			Rez(N2)=Rez(N2)+X(i)
		enddo
		
		ix=nedges+1
		do i=nodes+1, M
			Rez(i)=X(ix)
			ix=ix+1
		end do							
	endif
	end	
	
	function checkX(i)
	use OblastByEdge
	use parametrs	
	implicit real*8 (a-h, o-z)	
	
	do ix=1, num_0
		if(i.eq.nbondary_zero(ix))then
			checkX=1
			return
		endif
	enddo
	checkX=0
	end	
	
	
	function FindCheckBonds(i)
	use OblastByEdge
	use ForSolver
	use parametrs		
	implicit real*8 (a-h, o-z)
	integer Flag
	
	if(i.gt.nodes)then  ! i>nodes, то ищем среди ребер !!! ѕќƒќ«–»“≈Ћ№Ќќ≈ ћ≈—“ќ!!!!!!!!!
		ii=i-nodes
		do ix=1, num_0
		  if(ii.eq.nbondary_zero(ix))then
			FindCheckBonds=1
			return
		  endif 
		enddo
		do ix=1, num_E0
		  if(ii.eq.nbondary_one(ix))then
			FindCheckBonds=1
			return
		  endif 
		enddo			
	else
		do ix=1, node_0
		  if(i.eq.nodes_bondary_zero(ix))then
			FindCheckBonds=1
			return
		  endif 
		enddo							
	endif	  
	FindCheckBonds=0
	end
	
	
	function Scalar(X,Y,N)
	implicit complex*16 (a-h, o-z)
	real*8 a, b, s
	complex*16 X(N), Y(N)
	
	s=0.D0
	a=0.D0
	b=0.D0
	do i=1, N
		a=REAL(X(i))
		b=REAL(Y(i))
		s=s+a*b
		a=AIMAG(X(i))
		b=AIMAG(Y(i))
		s=s+a*b
	enddo
	Scalar=s
	end	